# 6. 생산자 소비자 문제 1  
- 기본 개념  
  - 생산자(Producer) : 데이터를 생성하는 역할  
  - 소비자(Consumer) : 생성된 데이터를 사용하는 역할  
  - 버퍼(Buffer) : 생산자가 생성한 데이터를 일시적으로 저장하는 한정된 크기의 공간(임계 영역)  
  <img width="876" height="335" alt="스크린샷 2025-12-02 230902" src="https://github.com/user-attachments/assets/258e6df1-8b80-4270-b60e-f832fe24c9c9" />
  
- 문제 상황  
  - 생산자가 너무 빠를 때 : 버퍼에 생산한 데이터를 저장하고, 버퍼가 가득 차 있으면 빈 공간이 생길 때까지 기다림.  
  - 소비자가 너무 빠를 때 : 버퍼에 저장된 데이터를 소비하고, 버퍼가 비어있으면 새로운 데이터가 저장될 때까지 기다림.  
  
- 한정된 버퍼 크기 문제 케이스  
  - 소비자 스레드들이 먼저 종료되어 데이터를 소비할 스레드가 없어,  
    버퍼(queue)에 데이터가 가득 차버리고, 남은 생산자가 새로 생성된 데이터는 버려짐.  
  <img width="879" height="509" alt="스크린샷 2025-12-02 230933" src="https://github.com/user-attachments/assets/c2a8c0fc-4c74-4ebe-a864-e8c884edfc47" />

  - 생산자 스레드들이 먼저 종료되어 데이터를 생산할 스레드가 없어,  
    버퍼(queue)가 비어버리므로 남은 소비자가 데이터를 받을 수 없음.
  <img width="851" height="475" alt="스크린샷 2025-12-02 230950" src="https://github.com/user-attachments/assets/73808595-a20f-4575-94fd-eb873b9871d7" />
  
  
- `sleep()` 을 이용하여 생산자/소비자가 기다릴 경우 문제 케이스  
  - 버퍼가 가득 차버린 상황에서 락을 가진 생산자는 버퍼에 자리가 남기만을 계속 기다리지만,  
  데이터를 소비할 소비자는 락이 없어 BLOCKED 상태가 되기 때문에 데드락 발생.  
  <img width="903" height="523" alt="스크린샷 2025-12-02 232050" src="https://github.com/user-attachments/assets/7a34a44a-a2f1-4c06-a84a-7e7a62bd5355" />
  <img width="890" height="578" alt="스크린샷 2025-12-02 232129" src="https://github.com/user-attachments/assets/4e14f8cd-3e4e-4d3a-9f5e-cb0dc8aa56fe" />


  - 버퍼가 비어 있는 상황에서 소비자는 락을 들고 버퍼에 데이터가 저장되기를 계속 기다리지만,  
  생산자는 락이 없어 BLOCKED 상태가 되기 때문에 데드락 발생.  
  <img width="882" height="370" alt="스크린샷 2025-12-02 232139" src="https://github.com/user-attachments/assets/f6f49b94-fe62-4c20-a4fd-4afaca8f20fe" />
  <img width="925" height="473" alt="스크린샷 2025-12-02 232601" src="https://github.com/user-attachments/assets/bed2aa08-627e-4ebe-92eb-81a352dab364" />
  
  
- Object - wait, notify
  - `Object.wait()` : 현재 스레드가 가진 락을 반납하고 대기(WAITING) 상태로 전환  
  - `Object.notify()` : 대기 중인 스레드 중 하나를 깨움  
  - `Object.notifyAll()` : 대기 중인 모든 스레드를 깨움  

  결국, 데이터를 소비(Consumer)하거나 저장(Producer)하지 못한 스레드는  
  `Object.wait()` 메서드를 통해 `WAITING` 상태로 전환(스레드 대기 집합에서 대기)하고  
  이후에 데이터가 저장되거나 큐에 공간이 남았을 때 `Object.notify()` 메서드로 깨움으로써  
  임계영역에서의 데드락 방지.  

  ```
  public class BoundedQueueImpl implements BoundedQueue {
  
      private final Queue<String> queue = new ArrayDeque<>();
      private final int max;
      public BoundedQueueImpl(int max) {
          this.max = max;
      }
    
      public synchronized void put(String data) {
          while (queue.size() == max) {
              try {
                  wait(); // RUNNABLE -> WAITING, 락 반납
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
          }
          queue.offer(data);
          notify(); // 대기 스레드, WAIT -> BLOCKED
          //notifyAll(); // 모든 대기 스레드, WAIT -> BLOCKED
      }
  
      public synchronized String take() {
          while (queue.isEmpty()) {
              try {
                  wait();
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
          }
      }
  }
  ```  
  - 소비자 우선
  
  - 생산자 우선
  
- Object - wait, notify - 한계  
  이러한 방식은 스레드 대기 집합 하나에 생산자, 소비자 스레드를 모두 관리.  
  그리고 `notify()` 를 호출할 때 임의의 스레드가 선택되므로 큐에 데이터가 없는 상황에  
  소비자가 같은 소비자를 깨우거나, 큐에 데이터가 가득 차있는데 생산자가 같은 생산자를 깨우는  
  비효율이 발생할 수 있다는 한계가 있음.

  - 스레드 기아(thread starvation)  
  `notify()` 의 또 다른 문제점으로는 어떤 스레드가 깨어날 지 알 수 없기 때문에  
  특정 스레드는 운이 없으면 리소스 점유를 계속해서 못하는 스레드 기아 문제가 발생할 수 있음.  
  -> 이럴 경우엔 `notifyAll()`를 사용하여 스레드 기아 문제 해결 가능하나 여전히 위와 같은 비효율 문제는 존재.