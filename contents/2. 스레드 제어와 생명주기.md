# 2. 스레드 제어와 생명주기
- Thread의 상태
<img width="696" height="416" alt="쓰레드 생명주기" src="https://github.com/user-attachments/assets/78f99719-1bed-435f-9eaf-ff5b71d7f824" />

    - NEW: 스레드가 아직 시작되지 않은 상태  
    - RUNNABLE: 스레드가 실행 중이거나 실행될 준비가 된 상태로, start() 메서드가 호되면 스레드는 이 상태로 들어감  
    - BLOCKED: 스레드가 동기화 락을 기다리는 상태(ex.  synchronized 블록에 진입하기 위해 락을 얻어야 하는 경우)  
    - WAITING: 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태로, wait() , join() 메서드가 호출될 때 이 상태가 됨
    - TIMED_WAITING: 일정 시간 동안 기다리는 상태로, sleep/wait/join(long millis) 메서드가 호출되면 이 상태가 됨
    - TERMINATED: 스레드가 실행을 마친 상태(스레드는 한 번 종료되면 다시 시작할 수 없음)

- 체크 예외 재정의
  `Runnable` 인터페이스는 다음과 같이 정의되어 있으며, `run()` 메서드를 구현할때 `InterruptedException`와 같은 체크 예외를 던질 수 없음  
  (만약 체크 예외를 던지려고 하면 컴파일 오류 발생)
  ```
  public interface Runnable {
      void run();
  }
  ```

  ※ 체크 예외 재정의 규칙
    - 만약 자식 클래스가 부모 클래스보다 더 넓은 범위의 예외를 던질 경우,  
      해당 코드는 모든 예외를 제대로 처리하지 못해 예상치 못한 런타임 오류 초래 가능
    - 따라서, 자식 클래스에 재정의된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있음
    - 추가로 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없음  

  따라서 체크 예외를 run() 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 체크 예외를 try-catch 블록 내에서 처리하게 됨.  
  이는 예외 발생 시 예외가 적절히 처리되지 않아서 멀티스레딩 프로그램이 비정상 종료되는 상황을 방지할 수 있음.  
  

- Join : `.join()` 을 호출하는 스레드는 대상 스레드가 종료(`TERMINATED`) 상태가 될 때까지 대기

  ```
  public static void main(String[] args) throws InterruptedException {
      MyTask task = new MyTask();
      Thread thread = new Thread(task, "task");
      thread.start();

      thread.join(); // 대상 스레드(thread)이 TERMINATED 상태가 될 때까지 main 스레드는 대기
      ... 
  }

  static static class MyTask implements Runnable {
      ...
  }
  ```

  - join(ms) : 특정 시간 만큼만 대기
  ```
  public static void main(String[] args) throws InterruptedException {
      MyTask task = new MyTask();
      Thread thread = new Thread(task, "task");
      thread.start();

      thread.join(2000); // 대상 스레드(thread)이 TERMINATED 상태가 될 때까지 main 스레드는 최대 2초간 대기
      ...
  }
  ```
  
- interrupt : `WAITING` , `TIMED_WAITING` 같은 대기 상태의 스레드를 직접 깨워서 `RUNNABLE` 상태로 변경.
  ```
  public static void main(String[] args) throws InterruptedException {
      MyTask task = new MyTask();
      Thread thread = new Thread(task, "task");
      thread.start();
  
      sleep(4000);
  
      /* thread 상태가 WAITING 또는 TIMED_WAITING 이면, 
       * 즉 InterruptedException 예외를 던지는 메서드를 호출중이면 바로 깨움
       */
      thread.interrupt(); 
      ...
  }
  
  static class MyTask implements Runnable {
      /* Thread.interrupted()
       * 해당 스레드가 인터럽트 상태면 true 를 반환하고, 상태를 정상(false)으로 바꿈.
       * 인터럽트 상태가 아니면 false 를 반환하고 상태를 변경하지 않음.
       * */
      while (!Thread.interrupted()) { // main 스레드에서 인터럽트 호출시 task 스레드의 인터럽트 상태 변경
          ... 작업 중
      }
  }
  ```
  - 자바에서는 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상(false)으로 돌림.  
    스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 의도치 않게 계속 인터럽트가 발생하게 됨.  
    따라서, `Thread.interrupted()`를 활용하여 인터럽트 사용 이후 상태를 다시 정상으로 돌려두는 것을 권장.  
    (물론, 상황에 따라 다르게 사용하는 것이 중요!)

  ※ `isInterrupted()`는 특정 스레드의 상태를 변경하지 않고 스레드의 인터럽트 상태 값만 리턴

- yield : 특정 스레드가 크게 바쁘지 않은 상황이어서 스케줄링 큐에 대기 중인 다른 스레드에 CPU 실행 기회를 양보하고 싶을 때   
  `Thread.yield()` 메서드를 호출하면 현재 실행 중인 스레드가 `RUNNABLE` 상태를 유지하면서 CPU를 양보하도록 힌트를 줌.  
  단, `yield()` 는 운영체제의 스케줄러에게 단지 힌트를 제공할 뿐, 강제적인 실행 순서를 지정하지 않으며,  
  반드시 다른 스레드가 실행되는 것을 보장하지는 않음.

    ※ 자바의 스레드가 `RUNNABLE` 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있음.  
      - 실행 상태(`Running`): 스레드가 CPU에서 실제로 실행 중  
      - 실행 대기 상태(`Ready`): 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중  
  
