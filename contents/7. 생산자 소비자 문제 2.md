# 7. 생산자 소비자 문제 2  
- Lock Condition : 핵심은 생산자 스레드는 소비자 스레드에게, 반대로 소비자 스레드는 생산자 스레드에게 `notify` 를 해주면 됨.  
  이를 위해서는 결국 생산자 스레드가 대기하는 대기 집합과, 소비자 스레드가 대기하는 대기 집합을 둘로 나누면 해결 가능.  
  => `Lock`, `ReentrantLock` 을 활용하여 이러한 기능 구현.  

  ```
  public class BoundedQueueImpl implements BoundedQueue {
      private final Lock lock = new ReentrantLock();
      private final Condition producerCond = lock.newCondition(); // 생산자 대기 큐
      private final Condition consumerCond = lock.newCondition(); // 소비자 대기 큐
      private final Queue<String> queue = new ArrayDeque<>();
      private final int max;
  
      public BoundedQueueImpl(int max) {
          this.max = max;
      }
  
      @Override
      public void put(String data) {
          lock.lock();
          try {
              while (queue.size() == max) {
                  try {
                      producerCond.await();
                  } catch (InterruptedException e) {
                      throw new RuntimeException(e);
                  }
              }
              queue.offer(data);
              consumerCond.signal();
          } finally {
              lock.unlock();
          }
      }
  
      @Override
      public String take() {
          lock.lock();
          try {
              while (queue.isEmpty()) {
                  try {
                      consumerCond.await();
                  } catch (InterruptedException e) {
                      throw new RuntimeException(e);
                  }
              }
              String data = queue.poll();
              producerCond.signal();
              return data;
          } finally {
              lock.unlock();
          }
      }
  }
  ```  
  - `put(data)` : 생산자 스레드가 호출  
    - 큐가 가득 찬 경우: `producerCond.await()` 를 호출해서 생산자 스레드를 생산자 전용 스레드 대기 공간에 보관.  
    - 데이터를 저장한 경우 : `consumerCond.signal()` 를 호출하여 소비자 전용 스레드 대기 공간에 있는 소비자 스레드 하나를 깨움.  
  - `take()` : 소비자 스레드가 호출  
    - 큐가 빈 경우 : `consumerCond.await()` 를 호출해서 소비자 스레드를 소비자 전용 스레드 대기 공간에 보관.  
    - 데이터를 소비한 경우 : `producerCond.signal()` 를 호출해서 생산자 전용 스레드 대기 공간에 있는 생산자 스레드 하나를 깨움.
    
  - 생산자 스레드가 데이터 생성 및 저장 후 소비자 스레드를 깨움.  
  <img width="854" height="659" alt="스크린샷 2025-12-06 232105" src="https://github.com/user-attachments/assets/e50bf9db-f9f6-473e-aca3-ef4a5c5e8b22" />
  <img width="853" height="657" alt="스크린샷 2025-12-06 232115" src="https://github.com/user-attachments/assets/9581ffbc-b3cc-44ad-b8b0-03eb489593ac" />
    
  - 소비자 스레드가 데이터 소비 후 생산자 스레드를 깨움.  
  <img width="860" height="664" alt="스크린샷 2025-12-06 232129" src="https://github.com/user-attachments/assets/d406db53-e0b7-4d42-aa86-031296f3cb68" />
  <img width="859" height="667" alt="스크린샷 2025-12-06 232142" src="https://github.com/user-attachments/assets/34b161e4-871f-403a-9a2b-a000feeac452" />
  
  
  - Object.notify() vs Condition.signal()  
    - Object.notify() : 대기 중인 스레드 중 임의의 하나를 선택해서 깨우며, 스레드가 깨어나는 순서는 정의되어 있지 않음(JVM 구현에 따라 다름)  
    - Condition.signal() : 대기 중인 스레드 중 하나를 깨우며, 일반적으로는 FIFO 순서로 깨움.  
  
  
- BlockingQueue : 위에서 정리해왔던 `BoundedQueue` 와 같이,  
  자바에서 생산자 소비자 문제를 해결하기 위해 제공하는 `java.util.concurrent.BlockingQueue` 인터페이스와 구현체.  
  ```
  package java.util.concurrent;
  // 자바에서 제공하는 BlockingQueue 인터페이스
  public interface BlockingQueue<E> extends Queue<E> { // Queue를 상속받았기 때문에 큐의 기능들도 사용 가능.
      // 데이터 추가 메서드
      boolean add(E e);
      boolean offer(E e);
      void put(E e) throws InterruptedException;
      boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
      
      // 데이터 획득 메서드
      E take() throws InterruptedException;
      E poll(long timeout, TimeUnit unit) throws InterruptedException;
      boolean remove(Object o);
      //...
  }
  ```
  ```
  // 소비자 스레드 BlockingQueue 사용 예시
  public class ConsumerTask implements Runnable {

    private final BlockingQueue<String> queue;

    public ConsumerTask(int max) {
        this.queue = new ArrayBlockingQueue<>(max);
    }

    @Override
    public void run() {
        ...
        String data = queue.take();
        ...
    }
  }
  ```
  ```
  // 생산자 스레드 BlockingQueue 사용 예시
  public class ProducerTask implements Runnable {

    private final BlockingQueue<String> queue;
    private final String request;

    public ProducerTask(String request, int max) {
        this.queue = new ArrayBlockingQueue<>(max);
        this.request = request;
    }

    @Override
    public void run() {
        ...
        queue.put(request);
        ...
    }
  }
  ```
  
- BlockingQueue 주요 기능
  - Throws Exception - 대기시 예외
    - add(e): 지정된 요소를 큐에 추가하며, 큐가 가득 차면 `IllegalStateException` 예외를 던짐.
    - remove(): 큐에서 요소를 제거하며 반환. 큐가 비어 있으면 `NoSuchElementException` 예외를 던짐.
    - element(): 큐의 머리 요소를 반환하지만, 요소를 큐에서 제거하지 않음. 큐가 비어 있으면 `NoSuchElementException` 예외를 던짐.
  - Special Value - 대기시 즉시 반환
    - offer(e): 지정된 요소를 큐에 추가하려고 시도하며, 큐가 가득 차면 `false` 를 반환.  
    - poll(): 큐에서 요소를 제거하고 반환. 큐가 비어 있으면 `null` 을 반환.  
    - peek(): 큐의 머리 요소를 반환하지만, 요소를 큐에서 제거하지 않음. 큐가 비어 있으면 `null` 을 반환.  
  - Blocks - 대기
    - put(e): 지정된 요소를 큐에 추가할 때까지 대기. 큐가 가득 차면 공간이 생길 때까지 대기.
    - take(): 큐에서 요소를 제거하고 반환. 큐가 비어 있으면 요소가 준비될 때까지 대기.
  - Times Out - 시간 대기
    - offer(e, time, unit): 지정된 요소를 큐에 추가하려고 시도하며, 지정된 시간 동안 큐가 비워지기를 기다리다가 시간이 초과되면 `false` 를 반환.
    - poll(time, unit): 큐에서 요소를 제거하고 반환. 큐에 요소가 없다면 지정된 시간 동안 요소가 준비되기를 기다리다가 시간이 초과되면 `null` 을 반환.