# 10. 스레드 풀과 Executor 프레임워크
- 
- Executor 프레임워크 : 자바의 Executor 프레임워크는 멀티스레딩 및 병렬 처리를 쉽게 사용할 수 있도록 돕는 기능의 모음.  
  덕분에 스레드 생성과 관리를 사용자가 직접 하지 않아도 되고, 반환값이 없는 Runnable 인터페이스의 단점을 보완하여 스레드를 편리하게 다룰 수 있음.  

- Executor 프레임워크의 주요 구성 요소
  - Executor 인터페이스
    ```
    package java.util.concurrent;
    public interface Executor {
        void execute(Runnable command);
    }    
    ```
  - ExecutorService 인터페이스 - 주요 메서드
    ```
    public interface ExecutorService extends Executor, AutoCloseable {
        <T> Future<T> submit(Callable<T> task);
      
        @Override
        default void close(){...}
        ...
    }
    ```

- ExecutorService 사용 예제
  ```
  // RunnableTask
  public class RunnableTask implements Runnable {
      ...
      private int sleepMs = 1000;
      ...
      @Override
      public void run() {
          sleep(sleepMs); // 작업 시간 시뮬레이션
      }
  }
  
  // ExecutorService
  public class ExecutorBasicMain {
      public static void main(String[] args) throws InterruptedException {
          // ExecutorService 의 가장 대표적인 구현체는 ThreadPoolExecutor
          ExecutorService es = new ThreadPoolExecutor(
             2, // corePoolSize
             2, // maximumPoolSize
             0, // keepAliveTime
             TimeUnit.MILLISECONDS, // TimeUnit(keepAliveTime 시간 단위)
             new LinkedBlockingQueue<>() // BlockingQueue 구현체
          );
  
          es.execute(new RunnableTask("taskA"));
          es.execute(new RunnableTask("taskB"));
          es.execute(new RunnableTask("taskC"));
          es.execute(new RunnableTask("taskD"));
          es.close();
      }
  }
  ```
    
  - ThreadPoolExecutor(ExecutorService) 구성요소
    1. 스레드 풀 : 스레드 관리
    2. `BlockingQueue` : 작업을 보관
  - `ThreadPoolExecutor` 생성자 파라미터
    1. `corePoolSize` : 스레드 풀에서 관리되는 기본 스레드의 수
    2. `maximumPoolSize` : 스레드 풀에서 관리되는 최대 스레드 수
    3. `keepAliveTime`, `TimeUnit unit` : 기본 스레드 수를 초과해서 만들어진 스레드가 생존할 수 있는 대기 시간.  
       이 시간 동안 처리할 작업이 없다면 초과 스레드는 제거됨.
    4. `BlockingQueue` workQueue : 작업을 보관할 블로킹 큐

  
- 동작 방식 예시
  <img width="911" height="511" alt="스크린샷 2026-01-18 221456" src="https://github.com/user-attachments/assets/2c3c6d49-e52f-4f7d-9c38-2e244211eb80" />  
  <img width="883" height="627" alt="스크린샷 2026-01-18 221513" src="https://github.com/user-attachments/assets/cb9c4f2a-24b5-4aa4-b34b-4fcc5bd36c0c" />  
  <img width="879" height="626" alt="스크린샷 2026-01-18 221522" src="https://github.com/user-attachments/assets/7a8ebe9f-d7de-4f0b-8a2c-57ec815522d1" />  
  <img width="869" height="617" alt="스크린샷 2026-01-18 221529" src="https://github.com/user-attachments/assets/5008698e-8b44-4f9b-9549-b019985fc4b8" />  
  

- Runnable 인터페이스의 단점  
  1. run() 메서드는 반환 값이 없으므로 스레드의 실행 결과를 얻기 위해서는 별도의 메커니즘이 필요
  2. run() 메서드는 체크 예외(checked exception)를 던질 수 없으므로 체크 예외의 처리는 메서드 내부에서 처리해야 함.
  ```
  package java.lang;
  
  public interface Runnable { // 체크 예외를 던질 수 없음
      void run(); // 반환 타입이 없음
  }
  ```


- `Callable` 인터페이스
  ```
  package java.util.concurrent;
  
  public interface Callable<V> {
      V call() throws Exception; // 반환 타입(제너릭)이 있고, 체크 예외인 Exception과 그 하위 예외를 던질 수 있음.
  }
  ```
  
- `Callable`과 `Future` 사용 예시
  ```
  public class CallableMain {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
  
          // newFixedThreadPool(size) 를 통해 보다 편리하게 ExecutorService 생성
          ExecutorService es = Executors.newFixedThreadPool(1);
  
          /* submit() 을 통해 Callable 인스턴스를 작업으로 전달, 
             결과값이 Future 라는 특별한 인터페이스를 통해 리턴 */
          Future<Integer> future = es.submit(new MyCallable());
          
          Integer result = future.get(); // Future 로부터 실제 결과값을 리턴
          es.close();
  }
  
  static class MyCallable implements Callable<Integer> {
      @Override
      public Integer call() {
          int value = 0;
          ... 
          return value;
      }
  } 
  ```
  
- 작동 방식
1. `es.submit()` 으로 작업 실행을 요청한 뒤, main 스레드는 바로 다음 작업을 이어서 진행.
2. 이후 `future.get()` 할 때, `future`가 완료될 때 까지 main 스레드는 블로킹(WAITING) 상태.
3. 실제로 스레드 작업이 끝나서 `future`에서 결과값이 리턴되면 main 스레드는 RUNNABLE 상태로 돌아옴.


- `Future`가 필요한 이유
  만약 작업 요청과 동시에 스레드의 작업이 끝나서 결과값이 리턴이 될 때까지 기다릴 경우,  
  멀티 스레드가 아닌 단일 스레드로 작업한 것과 다름이 없음.  
  즉, 다음과 같이 작업 시간이 2초가 걸리는 Task가 있다고 할 때, 전체 작업 시간은 Task의 수와 비례.  
  
  따라서, 작업 요청과 결과값 리턴 단계를 분리하여 먼저 여러 스레드들에 대해 Task 들을 요청하고  
  각각의 스레드들의 작업이 끝날 때 결과를 리턴받는 것이 더 효율적.  
  

- `Future`를 잘못 사용하는 예시 : 총 2초면 완료될 작업을 비효율적으로 4초가 소모됨.
  ```
  // 예시 1
  Future<Integer> future1 = es.submit(task1); // non-blocking
  Integer sum1 = future1.get(); // blocking, 2초 대기
  
  Future<Integer> future2 = es.submit(task2); // non-blocking
  Integer sum2 = future2.get(); // blocking, 2초 대기 
  ```
  ```
  // 예시 2
  Integer sum1 = es.submit(task1).get(); // get()에서 블로킹
  Integer sum2 = es.submit(task2).get(); // get()에서 블로킹
  ```

- `Future` Cancel : 아직 완료되지 않은 작업을 취소
  ```
  boolean cancel(boolean mayInterruptIfRunning);
  ```
  - `cancel(true)` : `Future` 를 취소 상태로 변경. 이때 작업이 실행중이라면 `Thread.interrupt()` 를 호출해서 작업을 중단.
  - `cancel(false)` : `Future` 를 취소 상태로 변경. 단, 이미 실행 중인 작업을 중단하지는 않음.
  

- `Future` 예외 : Future.get() 을 호출하면 작업의 결과값 뿐만 아니라, 작업 중에 발생한 예외도 받을 수 있음.
  ```
  ...
  ExecutorService es = Executors.newFixedThreadPool(1);
  Future<Integer> future = es.submit(new ExCallable());
  try {
      Integer result = future.get(); // 작업 스레드는 Future 에 발생한 예외를 담아둠(이때 Future의 상태는 FAILED)
  } catch (InterruptedException e) {
      throw new RuntimeException(e);
  } catch (ExecutionException e) {
      Throwable cause = e.getCause(); // 원본 예외
  }
  ... 
  
  static class ExCallable implements Callable<Integer> {
      @Override
      public Integer call() {
          throw new IllegalStateException("ex!");
      }
  }
  ```
  
- 작업 컬렉션 처리
  - `invokeAll()`
  ```
  // 모든 Callable 작업을 제출하고, 모든 작업이 완료될 때까지 기다림
  List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) 
      throws InterruptedException
   
  // 지정된 시간 내에 모든 Callable 작업을 제출하고 완료될 때까지 기다림
  List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) 
      throws InterruptedException
  ```
  
  - `invokeAny()` : 
  ``` 
  // 하나의 Callable 작업이 완료될 때까지 기다리고, 가장 먼저 완료된 작업의 결과를 반환
  T invokeAny(Collection<? extends Callable<T>> tasks) 
      throws InterruptedException, ExecutionException
  
  // 지정된 시간 내에 하나의 Callable 작업이 완료될 때까지 기다리고, 가장 먼저 완료된 작업의 결과를 반환
  T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) 
      throws InterruptedException, ExecutionException, TimeoutException
  ```