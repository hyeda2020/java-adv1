# 3. 메모리 가시성
- 메모리 가시성 문제(Memory Visibility) : 멀티스레드 환경에서 하나의 스레드가 변경한 값이 다른 스레드에 언제 보이는지에 대한 문제.  
  가령, 아래와 같이 main 스레드에서 1초 뒤에 `runFlag` 변수 값을 `false`로 바꾸고, 그 즉시 task 스레드에서 while문을 종료하는  
  간단한 로직이 있을때, 실제로 구동시켜 보면 task 스레드가 1초 뒤에 종료되지 않고 계속 while문 안에서 갇혀 있음.  
  ```
  public class VolatileFlagMain {
    public static void main(String[] args) {
      MyTask task = new MyTask();
      Thread t = new Thread(task, "work");
      t.start();
      sleep(1000);
      task.runFlag = false;
    }
  
    static class MyTask implements Runnable {
      boolean runFlag = true;
      
      @Override
      public void run() {
        while (runFlag) {
          // runFlag가 false로 변하면 탈출
        }
      }
    }
  }
  ```
  
  
- 로직상 메모리 구조  
  <img width="787" height="463" alt="스크린샷 2025-11-15 오후 9 53 53" src="https://github.com/user-attachments/assets/590e17e3-4b53-43b6-8699-de0f8556b62e" />  

  
- 실제 메모리 구조  
  <img width="786" height="463" alt="스크린샷 2025-11-15 오후 10 03 07" src="https://github.com/user-attachments/assets/01a9d7f1-39bf-4af8-9e96-a8bd81cc6357" />  
  실제로 CPU에서는 메인메모리에 접근하는 시간을 절약하기 위해 캐시메모리를 사용하게 되는데,  
  스레드에서 메인메모리로부터 변수 값을 캐시메모리로 불러온 후 해당 변수값을 바꾸면 해당 스레드 코어의 캐시메모리에만 적용되고,  
  메인메모리에는 바로 적용되지 않음. 또한, 메인메모리에 변수값의 변동사항이 적용되었다고 하더라도, 다른 스레드에도 바로 적용된다고 보장할 수 없음.  
  
  
- valotile  
  성능보다 여러 스레드에서 같은 시점에 같은 데이터를 보는 것이 중요한 경우, `valotile` 키워드를 사용하여  
  성능을 약간 포기하는 대신, 값을 읽을 때와 쓸 때 모두 메인 메모리에 직접 접근하도록 설정 가능.
  ```
  ...
  static class MyTask implements Runnable {
      volatile boolean runFlag = true; // volatile 키워드 적용
      
      @Override
      public void run() {
        while (runFlag) {
          // runFlag가 false로 변하면 탈출
        }
      }
  }
  ```
  <img width="786" height="439" alt="스크린샷 2025-11-15 오후 10 20 08" src="https://github.com/user-attachments/assets/8990868f-cf1d-4037-910e-bb063851bfa4" />

  ※ `valotile` 뿐만 아니라 스레드 동기화 기법(`synchronized`, `ReentrantLock`)을 사용하면 메모리 가시성 문제를 피할 수 있음!

