# 5. 동기화 - concurrent.Lock

- `synchronized` 의 단점  
  - 무한 대기 : 락을 획득하지 못한 스레드는 `BLOCKED` 상태에 빠지게 되며, 인터럽를 통해서도 깨어나지 못함.  
  - 공정성 : 락이 돌아왔을 때 `BLOCKED` 상태의 여러 스레드들 중에 어떤 스레드가 락을 획득할 지 알 수 없음.  
  
  
- LockSupport : `synchronized` 와 다르게 스레드를 `WAITING` 또는 `TIMED_WAITING` 상태로 변경.  
  (`WAITING` 상태의 스레드는 인터럽트를 통해서도 깨울 수 있음)  
  ```
  public static void main(String[] args) {
      Thread thread1 = new Thread(new ParkTask(), "Thread-1");
      thread1.start();
      sleep(100);  // 잠시 대기하여 thread1이 park 상태에 빠질 시간을 준다.
      LockSupport.unpark(thread1); // 1. unpark를 통해 스레드를 깨움
      // thread1.interrupt(); // 2. interrupt를 통해 스레드를 깨움
  }
  
  static class ParkTask implements Runnable {
      @Override
      public void run() {
          LockSupport.park(); // WAITING
          ...
      }
  }
  ```
  <img width="623" height="600" alt="스크린샷 2025-11-30 194358" src="https://github.com/user-attachments/assets/cc0f8f36-b500-4539-9509-befb5dc5c905" />


- 시간 대기 : LockSupport는 `parkNanos(nanos)` 스레드를 특정 시간만 대기하는 `TIMED_WAITING` 상태로 변경 가능  
  ```
  public static void main(String[] args) {
      Thread thread1 = new Thread(new ParkTask(), "Thread-1");
      thread1.start();
      sleep(100);  // 잠시 대기하여 thread1이 park 상태에 빠질 시간을 준다.
  }
  
  static class ParkTask implements Runnable {
      @Override
      public void run() {
          LockSupport.parkNanos(2000_000000); // parkNanos 사용하여 2초간 대기
          ...
      }
  }
  ```
  <img width="711" height="582" alt="스크린샷 2025-11-30 194647" src="https://github.com/user-attachments/assets/4518106b-5743-41a0-b618-4a76cc5703e6" />

  
  결국, `LockSupport` 를 사용하면 스레드를 `WAITING` 또는 `TIMED_WAITING` 상태로 변경할 수 있어  
  `synchronized` 의 단점인 무한 대기 문제 해결 가능.  
  
  
- ReentrantLock : `synchronized` 와 `BLOCKED` 상태를 통한 통한 임계 영역 관리의 한계를 극복하기 위해  
  자바 1.5부터 `Lock` 인터페이스와 `ReentrantLock` 구현체를 제공.(단, 이때의 락은 객체 내부에 있는 모니터 락이 아님!)  
  특히, `ReentrantLock` 구현체는 공정 모드를 통해 이는 먼저 대기한 스레드가 먼저 락을 획득하게 하여 스레드 간의 공정성을 보장.  
  ```
  package java.util.concurrent.locks;
  // Lock 인터페이스
  public interface Lock {
      void lock();
      void lockInterruptibly() throws InterruptedException;
      boolean tryLock();
      boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
      void unlock();
      Condition newCondition();
  }
  ```
  ```
  import java.util.concurrent.locks.ReentrantLock;
  // ReentrantLock 구현체 사용 예시
  public class ReentrantLockEx {
      // 비공정 모드 락
      private final Lock nonFairLock = new ReentrantLock();
      // 공정 모드 락
      private final Lock fairLock = new ReentrantLock(true);

      public void fairLockTest() {
          fairLock.lock();
          try {
          // 임계 영역
          } finally {
              fairLock.unlock();
          }
      }
  }
  ```
  - 비공정 모드는 성능을 중시하여 스레드가 락을 빨리 획득할 수 있지만, 특정 스레드가 계속해서 락을 획득하지 못할 수 있음.  
  - 공정 모드는 스레드가 락을 획득하는 순서를 보장하여 공정성을 중시하지만, 성능이 저하될 수 있음.  
  
  
- ReentrantLock - 대기 중단 : `ReentrantLock` 을 사용하면 락을 무한 대기하지 않고, 중간에 빠져나오는 것이 가능하며,  
  심지어 락을 얻을 수 없다면 기다리지 않고 즉시 빠져나오는 것도 가능.  
  - `boolean tryLock()` : 락 획득을 시도하고, 즉시 성공 여부를 반환(true/false)  
  - `boolean tryLock(long time, TimeUnit unit)` : 주어진 시간동안 락 획득을 시도하고, 주어진 시간 안에 락을 획득하면 true 를,  
    주어진 시간이 지나도 락을 획득하지 못한 경우 false 를 반환.  
    이 메서드는 대기 중 인터럽트가 발생하면 `InterruptedException` 을 던지며 락 획득을 포기.  
  ```
  // tryLock() 사용 예시
  public class BankAccountImpl implements BankAccount {
      ...
      private final Lock lock = new ReentrantLock();

      @Override
      public boolean withdraw(int amount) {
          if (!lock.tryLock()) { // 락을 획득할 수 없으면 대기하지 않고 바로 포기
              return false;
          }
          try {
              if (balance < amount) {
                  return false;
              }
              sleep(1000);
              balance = balance - amount;
          } finally {
              lock.unlock(); // ReentrantLock 이용하여 lock 해제
          }
          return true;
      }
  }
  ```
  
