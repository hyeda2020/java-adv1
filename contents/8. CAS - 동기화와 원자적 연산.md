# 8. CAS - 동기화와 원자적 연산  
- 원자적 연산(atomic operation) : 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것.  
  즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있음.  
  예를 들어, `i = 1;` 는 단 하나의 순서로 실행되기 때문에 원자적 연산이지만,  
  `i = i + 1;` 는 다음과 같은 순서로 나누어 실행되기 때문에 원자적 연산이 아님.  
  ```
  1) 오른쪽에 있는 i 의 값을 읽는다. i 의 값은 10이다.
  2) 읽은 10에 1을 더해서 11을 만든다.  
  3) 더한 11을 왼쪽의 i 변수에 대입한다.  
  ```

  원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않음.  
  하지만 원자적 연산이 아닌 경우에는 `synchronized` 블럭이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 함.  
  
  
- 원자적 연산 - AtomicInteger  
  자바에서는 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 `AtomicInteger` 라는 클래스를 제공.  
  ```
  public class MyAtomicInteger implements IncrementInteger {
      AtomicInteger atomicInteger = new AtomicInteger(0); // 초기값을 지정. 생략하면 0 부터 시작.

      @Override
      public void increment() {
          atomicInteger.incrementAndGet(); // 값을 하나 증가하고 증가된 결과를 반환
      }

      @Override
      public int get() {
          return atomicInteger.get(); // 현재 값을 반환
      }
  }
  ```
  
- 성능 비교(`synchronized` vs `AtomicInteger`)  
  `synchronized`, `Lock` 같은 락은 공유 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한하며,  
  특정 스레드가 락을 획득하기 위해 대기하거나(WAITING) 반납하는 등의 오버헤드 발생.  
  반면, `AtomicInteger`는 락을 사용하지 않는 CAS 연산으로, 보다 성능이 빠름.  
  
  
- CAS 연산 : `synchronized` 와 같은 락이 가진 성능적인 이슈를 보완하기 위해 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법.  
  단, CAS 연산이 락을 완전히 대체하는 것은 아니고, 작은 단위의 일부 영역에 적용할 수 있음.  
  즉, 기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있음.

  - `compareAndSet(0, 1)` : `AtomicInteger` 가 제공하는 원자적 메서드로,  
    만약 atomicInteger 의 값이 현재 0이라면 atomicInteger 의 값을 1로 변경하고 `true` 를 반환.  
    만약 atomicInteger 의 값이 현재 0이 아니라면 atomicInteger 의 값은 변경되지 않으며, 이 경우 `false` 를 반환.
  
  - CPU 하드웨어의 지원
    <img width="916" height="606" alt="스크린샷 2025-12-19 223421" src="https://github.com/user-attachments/assets/52310651-4e8b-4ba2-a1f3-98d65fef696e" />
    사실 위 명령어는 아래와 같은 두 단계로 이루어진 명령어로, 원자적이지 않은 연산처럼 보임.  
    ```
    1. 먼저 메인 메모리(x001)에 있는 값을 확인
    2. 해당 값이 기대하는 값(0)이라면 원하는 값(1)으로 변경
    ```
    CAS 연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서  
    특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능.  
    따라서, 위 두 단계의 명령이 수행되는 동안 CPU에서 해당 메모리에 다른 스레드가 접근하지 못하도록 막음으로써  
    CAS 연산이 원자적으로 수행될 수 있도록 함.
  
  - `incrementAndGet()` 구현 예시
    ```
    private static int incrementAndGet(AtomicInteger atomicInteger) {
        int getValue;
        boolean result;
        do {
            getValue = atomicInteger.get(); // value 값을 읽음.
            result = atomicInteger.compareAndSet(getValue, getValue + 1); // CAS 연산 사용하여 값 증가
        } while (!result);
        return getValue + 1;
    }
    ```
    만약 CAS 연산 구간인 `atomicInteger.compareAndSet(getValue, getValue + 1)` 에서  
    여러 스레드들의 동시 접근으로 인해 충돌이 발생할 경우, while 문을 돌면서 반복해서 충돌을 피할 때까지  
    다시 시도하므로 락 없이 안전하게 데이터 변경 가능.  
    즉, CAS를 사용하는 방식은 충돌이 드물게 발생하는 환경에서는 락을 사용하지 않으므로 높은 성능을 발휘할 수 있음.  
    그러나 반대로 그러나 충돌이 빈번하게 발생하는 환경에서는 반복문을 계속 돌기 때문에 CPU 자원을 많이 소모하여 성능 저하.  
    따라서, 간단한 CPU 연산에는 락 보다는 CAS를 사용하는 것이 효과적이고,  
    복잡한 비즈니스 로직에 대한 동기화에는 락을 사용하는 것이 바람직함.  

  - CAS 연산을 활용한 락 구현
    ```
    public class SpinLock {
        // CAS 연산을 지원하는 AtomicBoolean 을 사용
        private final AtomicBoolean lock = new AtomicBoolean(false);
    
        public void lock() {
            while (!lock.compareAndSet(false, true)) {
                // 락을 획득할 때 까지 스핀 대기(바쁜 대기) 한다.
            }
        }
  
        public void unlock() {
            lock.set(false);
        }
    }
    ```
    이렇게 CAS 연산을 사용해서 원자적인 연산을 만든 덕분에 무거운 동기화 작업 없이 아주 가벼운 락 구현 가능.  
    다만, 동기화 락을 사용하면 RUNNABLE 상태의 스레드가 BLOCKED, WAITING 상태에서 대기하므로  
    그 동안에 CPU 자원을 거의 사용하지 않고 아낄 수 있음.  
    반면, CAS 기반 락은 스레드가 RUNNABLE 상태로 while 문을 반복 실행하므로 CPU 자원을 계속해서 사용.  
    결론적으로, 일반적으로 동기화 락을 사용하고, 아주 특별한 경우에 한정해서 CAS를 사용해서 최적화하는 것인 중요!  

    예를 들어 숫자 값의 증가, 자료 구조의 데이터 추가, 삭제와 같이 CPU 사이클이 금방 끝나지만 안전한 임계 영역,  
    또는 원자적인 연산이 필요한 경우에 한정하여 사용해야 함.  
    반면에 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것 처럼 오래 기다리는 작업에 CAS를 사용하면  
    CPU를 계속 사용하며 기다리는 최악의 결과가 나올 수도 있으므로 이런 경우에는 동기화 락을 사용해야 함.  
