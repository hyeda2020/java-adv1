# 8. CAS - 동기화와 원자적 연산  
- 원자적 연산(atomic operation) : 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것.  
  즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있음.  
  예를 들어, `i = 1;` 는 단 하나의 순서로 실행되기 때문에 원자적 연산이지만,  
  `i = i + 1;` 는 다음과 같은 순서로 나누어 실행되기 때문에 원자적 연산이 아님.  
  ```
  1) 오른쪽에 있는 i 의 값을 읽는다. i 의 값은 10이다.
  2) 읽은 10에 1을 더해서 11을 만든다.  
  3) 더한 11을 왼쪽의 i 변수에 대입한다.  
  ```

  원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않음.  
  하지만 원자적 연산이 아닌 경우에는 `synchronized` 블럭이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 함.  
  
  
- 원자적 연산 - AtomicInteger  
  자바에서는 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 `AtomicInteger` 라는 클래스를 제공.  
  ```
  public class MyAtomicInteger implements IncrementInteger {
      AtomicInteger atomicInteger = new AtomicInteger(0); // 초기값을 지정. 생략하면 0 부터 시작.

      @Override
      public void increment() {
          atomicInteger.incrementAndGet(); // 값을 하나 증가하고 증가된 결과를 반환
      }

      @Override
      public int get() {
          return atomicInteger.get(); // 현재 값을 반환
      }
  }
  ```
  
- 성능 비교(`synchronized` vs `AtomicInteger`)  
  `synchronized`, `Lock` 같은 락은 공유 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한하며,  
  특정 스레드가 락을 획득하기 위해 대기하거나(WAITING) 반납하는 등의 오버헤드 발생.  
  반면, `AtomicInteger`는 락을 사용하지 않는 CAS 연산으로, 보다 성능이 빠름.  
  
  
- CAS 연산 : `synchronized` 와 같은 락이 가진 성능적인 이슈를 보완하기 위해 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법.  
  단, CAS 연산이 락을 완전히 대체하는 것은 아니고, 작은 단위의 일부 영역에 적용할 수 있음.  
  즉, 기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있음.  
  