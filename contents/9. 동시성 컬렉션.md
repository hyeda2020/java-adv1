# 9. 동시성 컬렉션
- `java.util` 패키지에 속한 컬렉션 프레임워크가 제공하는 연산들은 원자적 연산이 아니기 때문에  
    하나의 인스턴스(ex. `ArrayList`)에 여러 스레드가 동시에 접근할 경우, 데이터 Sync가 깨질 위험이 있음.
  
  
- 자바 synchronized 프록시 : 자바에서 제공하는 컬렉션을 위한 프록시 기능.  
    즉, 클라이언트는 인터페이스(List, Map 등)에 의존하고, 기본 구현체(ArrayList, HashMap 등)에 synchronized 기능을 씌운
    프록시 객체가 인터페이스를 구현.  
  ```
  // Proxy 객체 구현 예시
  public class SyncProxyList implements SimpleList {
    
      private SimpleList target;
    
      public SyncProxyList(SimpleList target) {
          this.target = target;
      }
    
      // add 연산에 synchronized 적용
      @Override
      public synchronized void add(Object e) {
          target.add(e); // 기본 구현체의 메소드를 호출
      }
  
      // get 연산에 synchronized 적용
      @Override 
      public synchronized Object get(int index) {
          return target.get(index); // 기본 구현체의 메소드를 호출
      }
  }
  ```
  
  ```
  // 실제 자바 synchronized 프록시 사용 예시
  // 클라이언트 -> SynchronizedRandomAccessList(프록시) -> ArrayList
  List<String> list = Collections.synchronizedList(new ArrayList<>());
  list.add("data1");
  list.add("data2");
  list.add("data3");
  System.out.println("list = " + list);
  ```
  - synchronized 프록시 방식의 단점  
  1) 각 메서드 호출 시마다 동기화 비용이 추가되어 이로 인해 성능 저하가 발생할 수 있음.  
  2) 전체 컬렉션에 대해 동기화가 이루어지기 때문에, 잠금 범위가 넓어져 정교한 동기화가 불가능.  
  
  
- 동시성 컬렉션 : `java.util.concurrent` 패키지에서 고성능 멀티스레드 환경을 지원하는 다양한 동시성 컬렉션 클래스들을 제공.  
  (Collections.synchronizedXxx 를 사용하는 것 보다 더 좋은 성능을 제공)

    - `List` : `CopyOnWriteArrayList`(`ArrayList` 의 대안)
    - `Set` : `CopyOnWriteArraySet`(`HashSet` 의 대안)
    - `Map` : `ConcurrentHashMap`(`HashMap` 의 대안)
    - `Queue` : `ConcurrentLinkedQueue`(동시성 큐, 비 차단(non-blocking) 큐)
    - `Deque` : `ConcurrentLinkedDeque`(동시성 데크, 비 차단(non-blocking) 큐)
    - `BlockingQueue`
      - `ArrayBlockingQueue` : 크기가 고정된 블로킹 큐, 공정(fair) 모드를 사용할 수 있으나 성능 저하
      - `LinkedBlockingQueue` : 크기가 무한하거나 고정된 블로킹 큐
      - `PriorityBlockingQueue` : 우선순위가 높은 요소를 먼저 처리하는 블로킹 큐
      - `SynchronousQueue` : 데이터를 저장하지 않는 블로킹 큐로,  
        생산자가 데이터를 추가하면 소비자가 그 데이터를 받을 때까지 대기