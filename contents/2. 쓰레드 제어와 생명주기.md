# 2. 스레드 제어와 생명주기
- Thread의 상태
<img width="696" height="416" alt="쓰레드 생명주기" src="https://github.com/user-attachments/assets/78f99719-1bed-435f-9eaf-ff5b71d7f824" />

    - NEW: 스레드가 아직 시작되지 않은 상태  
    - RUNNABLE: 스레드가 실행 중이거나 실행될 준비가 된 상태로, start() 메서드가 호되면 스레드는 이 상태로 들어감  
    - BLOCKED: 스레드가 동기화 락을 기다리는 상태(ex.  synchronized 블록에 진입하기 위해 락을 얻어야 하는 경우)  
    - WAITING: 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태로, wait() , join() 메서드가 호출될 때 이 상태가 됨
    - TIMED_WAITING: 일정 시간 동안 기다리는 상태로, sleep/wait/join(long millis) 메서드가 호출되면 이 상태가 됨
    - TERMINATED: 스레드가 실행을 마친 상태(스레드는 한 번 종료되면 다시 시작할 수 없음)

- 체크 예외 재정의
  `Runnable` 인터페이스는 다음과 같이 정의되어 있으며, `run()` 메서드를 구현할때 `InterruptedException`와 같은 체크 예외를 던질 수 없음  
  (만약 체크 예외를 던지려고 하면 컴파일 오류 발생)
  ```
  public interface Runnable {
    void run();
  }
  ```

  ※ 체크 예외 재정의 규칙
    - 만약 자식 클래스가 부모 클래스보다 더 넓은 범위의 예외를 던질 경우,  
      해당 코드는 모든 예외를 제대로 처리하지 못해 예상치 못한 런타임 오류 초래 가능
    - 따라서, 자식 클래스에 재정의된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있음
    - 추가로 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없음  

  따라서 체크 예외를 run() 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 체크 예외를 try-catch 블록 내에서 처리하게 됨.  
  이는 예외 발생 시 예외가 적절히 처리되지 않아서 멀티스레딩 프로그램이 비정상 종료되는 상황을 방지할 수 있음.  

- Join : `.join()` 을 호출하는 스레드는 대상 스레드가 종료(`TERMINATED`) 상태가 될 떄까지 대기

  ```
  public static void main(String[] args) throws InterruptedException {
      MyTask task = new MyTask();
      Thread thread1 = new Thread(task, "task");
      thread.start();

      thread.join(); // 대상 스레드(thread1)이 TERMINATED 상태가 될 때까지 main 스레드는 대기
      ... 
  }

  static class Job implements Runnable {
      ...
  }
  ```

  - join(ms) : 특정 시간 만큼만 대기
  ```
  public static void main(String[] args) throws InterruptedException {
      MyTask task = new MyTask();
      Thread thread1 = new Thread(task, "task");
      thread.start();

      thread.join(2000); // 대상 스레드(thread1)이 TERMINATED 상태가 될 때까지 main 스레드는 최대 2초간 대기
      ...
  }
  ```
 
    
