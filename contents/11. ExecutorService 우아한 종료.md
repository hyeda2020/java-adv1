# 11. ExecutorService 우아한 종료
- 우아한 종료 : 서버 기능을 업데이트를 위해서 서버를 재시작해야 할 때,  
  새로운 요청이 오는 것은 막고, 이미 진행중인 작업이 모두 완료한 다음에 재시작 하는 것 처럼 문제 없이 서비스를 종료하는 것.  
  

- `ExecutorService` 의 종료 메서드
  - `void shutdown()` : 새로운 작업을 받지 않고, 이미 제출된 작업(BlockingQueue에 있는 작업들 포함)을 모두 완료한 후에 종료.  
  - `List<Runnable> shutdownNow()` : 실행 중인 작업을 중단하고, 대기 중인 작업을 반환하며 즉시 종료.
  - `close()` : shutdown() 을 호출하고, 작업이 완료되거나 인터럽트가 발생할 때 까지 무한정 반복 대기.

  
- `Executor` 스레드 풀 관리 : BlockingQueue와 스레드 풀 관리 예시(기본 스레드 2개, 최대 스레드 4개)
  - BlockingQueue Size = 2
  - corePoolSize = 2
  - maximumPoolSize = 4

  
- 스레드 미리 생성하기  
  응답시간이 아주 중요한 서버인 경우, 스레드를 미리 생성해두면, 처음 요청에서 사용되는 스레드의 생성 시간을 줄일 수 있음.  
  `ThreadPoolExecutor.prestartAllCoreThreads()` 를 사용하면 기본 스레드를 미리 생성할 수 있음.  
  단, `ExecutorService` 는 이 메서드를 제공하지 않음.  
  ```
  public static void main(String[] args) {
      ExecutorService es = Executors.newFixedThreadPool(1000);
      ThreadPoolExecutor poolExecutor = (ThreadPoolExecutor) es;
      poolExecutor.prestartAllCoreThreads();
  }
  ```

- Executor 스레드 풀 관리 전략
  - 고정 스레드 풀 전략 : 스레드 풀에 nThreads 만큼의 기본 스레드를 생성 / 큐 사이즈에 제한이 없음.
    - 스레드 수가 고정되어 있기 때문에 CPU, 메모리 리소스가 어느정도 예측 가능한 안정적인 방식.
    - 다만, 작업량이 늘어나도 스레드 수가 고정되어 있어서 요청이 대기 큐에 계속 쌓이게 되므로  
      사용자 입장에서 성능이 점점 느려짐.
    ```
    new ThreadPoolExecutor(
        nThreads,
        nThreads,
        0L,
        TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>()
    );
    ```
- 캐시 스레드 풀 전략 : 기본 스레드를 사용하지 않고, 60초 생존 주기를 가진 초과 스레드만 사용 / 초과 스레드의 수는 제한 없음.
  - 큐에 작업을 저장하지 않으며, 대신에 생산자의 요청을 스레드 풀의 소비자 스레드가 직접 받아서 바로 처리
  - 요청이 갑자기 증가하면 스레드도 갑자기 증가하고, 요청이 줄어들면 스레드도 점점 줄어듦.
  - 따라서 성능이 매우 빠르고 유연하지만 CPU, 메모리 자원은 한계가 있기 때문에 시스템 자원을 너무 많이 사용하면서 시스템이 다운될 수 있음.
  ```
  new ThreadPoolExecutor(
      0,
      Integer.MAX_VALUE,
      60L,
      TimeUnit.SECONDS,
      new SynchronousQueue<Runnable>() // 내부에 저장 공간이 없으며, 생산자의 작업을 소비자 스레드에게 직접 전달.
  );
   ```

- 사용자 정의 풀 전략
  - 일반: CPU, 메모리 자원을 예측할 수 있도록 고정 크기의 스레드로 서비스를 안정적으로 운영.
  - 긴급: 사용자의 요청이 갑자기 증가하면 긴급하게 스레드를 추가로 투입해서 작업을 빠르게 처리.
  - 거절: 사용자의 요청이 폭증해서 긴급 대응도 어렵다면 사용자의 요청을 거절.
  ```
  new ThreadPoolExecutor(
      100, // 100개의 기본 스레드 사용
      200, // 추가로 긴급 대응 가능한 긴급 스레드 100개를 사용
      60,  //  긴급 스레드는 60초의 생존 주기를 가짐
      TimeUnit.SECONDS,
      new ArrayBlockingQueue<>(1000) // 1000개의 작업이 큐에 대기할 수 있음
  );  
  ```
  위와 같이 설정했을 경우, 1000개 이하의 작업이 큐에 담겨 있으면 100개의 기본 스레드가 처리함.  
  이후 큐에 담긴 작업이 1000개를 초과하면 100개의 초과 스레드가 추가되어  
  총 200개의 스레드가 작업을 처리함.  
  초과 스레드를 투입했지만, 큐에 담긴 작업 1000개를 초과하고 또 초과 스레드도 넘어가면 예외 발생.


- 실무에서 자주하는 실수  
  만약 아래처럼 큐 사이즈를 무한대로 설정할 경우,  
  큐가 가득 찰 수가 없기 때문에 긴급 상황으로 전환이 되지 않아 추가 스레드가 생성되지 않으므로  
  결국 100개 스레드로 계속 작업을 처리해야 되는 비효율 상황이 발생.
  ```
  new ThreadPoolExecutor(
      100,
      200,
      60,
      TimeUnit.SECONDS,
      new LinkedBlockingQueue()
  );
  ```

- Executor 예외 정책
  ```
  new ThreadPoolExecutor(
      1,
      1,
      0,
      TimeUnit.SECONDS,
      new SynchronousQueue<>(),
      new ThreadPoolExecutor.AbortPolicy() // DiscardPolicy, CallerRunsPolicy
  )  
  ```
  - AbortPolicy: 새로운 작업을 제출할 때 `RejectedExecutionException` 을 발생.
  - DiscardPolicy : 새로운 작업을 조용히 버림.
  - CallerRunsPolicy : 새로운 작업을 요청한 스레드가 대신해서 직접 작업을 실행함.
    - 이 경우 작업을 요청한 스레드가 직접 작업을 실행하게 되므로, 작업의 생산(요청)이 느려지게 됨.
    - 따라서 전체적으로 작업의 생산(요청) 속도가 조절되는 효과 발생.
  - 사용자 정의( RejectedExecutionHandler ): 개발자가 직접 정의한 거절 정책을 사용할 수 있음.
  ```
  new ThreadPoolExecutor(
      1,
      1,
      0,
      TimeUnit.SECONDS,
      new SynchronousQueue<>(),
      new MyRejectedExecutionHandler() // 사용자 정의 예외
  )   
  
  // 직접 RejectedExecutionHandler 인터페이스를 구현하여 사용자 정의 예외 생성
  static class MyRejectedExecutionHandler implements RejectedExecutionHandler {
      @Override
      public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
          ...
      }
  }
  ```